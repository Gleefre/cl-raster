;;;; Rasterization renderer.

(in-package #:cl-raster/core)

(ql:quickload :3d-vectors)
(use-package :3d-vectors)

(defun project-point-to-camera (camera point)
  (let* ((to-point-vector (v- (camera-get-center camera) point))
         (center-to-canvas-vector (v/ to-point-vector (v. to-point-vector (camera-get-direction camera))))
         (in-canvas-vector (v- center-to-canvas-vector (camera-get-direction camera)))
         (x-canvas-coordinate (v. (camera-get-x-vector camera) in-canvas-vector))
         (y-canvas-coordinate (v. (camera-get-y-vector camera) in-canvas-vector)))
    (list (round (* (/ (1+ x-canvas-coordinate) 2) (camera-get-width camera)))
          (round (* (/ (1+ y-canvas-coordinate) 2) (camera-get-height camera))))))

(defun triangle-contains (triangle point)
  (let ((a-to-point (v- point (first triangle)))
        (b-to-point (v- point (second triangle)))
        (c-to-point (v- point (third triangle)))
        (bc-perpendicular (vrot2 (v- (second triangle) (third triangle)) pi/2))
        (ca-perpendicular (vrot2 (v- (third triangle) (first triangle)) pi/2))
        (ab-perpendicular (vrot2 (v- (first triangle) (second triangle)) pi/2)))
    (and (< 0 (* (v. a-to-point bc-perpendicular)
                 (v. b-to-point ca-perpendicular)))
         (< 0 (* (v. b-to-point ca-perpendicular)
                 (v. c-to-point ab-perpendicular))))))

(defun render (scene camera)
    (let ((image (make-array (list (camera-get-width camera) (camera-get-height camera))
                             :initial-element '(0 0 0)))
          (depths (make-array (list (camera-get-width camera) (camera-get-height camera))
                              :initial-element NIL)))
      (loop for triangle in (scene-get-triangles scene)
            do (let* ((a-point (project-point-to-camera camera (first triangle)))
                      (b-point (project-point-to-camera camera (second triangle)))
                      (c-point (project-point-to-camera camera (third triangle)))
                      (minimal-x (max 0 (min (first a-point) (first b-point) (first c-point))))
                      (maximal-x (min (camera-get-width camera) (max (first a-point) (first b-point) (first c-point))))
                      (minimal-y (max 0 (min (second a-point) (second b-point) (second c-point))))
                      (maximal-y (min (camera-get-height camera) (max (second a-point) (second b-point) (second c-point)))))
                 (loop for pixel-x from minimal-x to maximal-x
                       for pixel-y from minimal-y to maximal-y
                       when (triangle-contains (list a-point b-point c-point) (list pixel-x pixel-y))
                       do (setf (aref image pixel-x pixel-y) '(255 255 255)))))
      image))
